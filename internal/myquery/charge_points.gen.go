// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package myquery

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"gorm.io/gen/internal/mymodel"
)

func newChargePoint(db *gorm.DB, opts ...gen.DOOption) chargePoint {
	_chargePoint := chargePoint{}

	_chargePoint.chargePointDo.UseDB(db, opts...)
	_chargePoint.chargePointDo.UseModel(&mymodel.ChargePoint{})

	tableName := _chargePoint.chargePointDo.TableName()
	_chargePoint.ALL = field.NewAsterisk(tableName)
	_chargePoint.ID = field.NewUint(tableName, "id")
	_chargePoint.CreatedAt = field.NewTime(tableName, "created_at")
	_chargePoint.UpdatedAt = field.NewTime(tableName, "updated_at")
	_chargePoint.DeletedAt = field.NewField(tableName, "deleted_at")
	_chargePoint.ChargingStationID = field.NewUint(tableName, "charging_station_id")
	_chargePoint.ChargingStation = chargePointBelongsToChargingStation{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("ChargingStation", "mymodel.ChargingStation"),
		City: struct {
			field.RelationField
			Province struct {
				field.RelationField
			}
		}{
			RelationField: field.NewRelation("ChargingStation.City", "mymodel.City"),
			Province: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("ChargingStation.City.Province", "mymodel.Province"),
			},
		},
		ChargePoints: struct {
			field.RelationField
			ChargingStation struct {
				field.RelationField
			}
		}{
			RelationField: field.NewRelation("ChargingStation.ChargePoints", "mymodel.ChargePoint"),
			ChargingStation: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("ChargingStation.ChargePoints.ChargingStation", "mymodel.ChargingStation"),
			},
		},
	}

	_chargePoint.fillFieldMap()

	return _chargePoint
}

type chargePoint struct {
	chargePointDo

	ALL               field.Asterisk
	ID                field.Uint
	CreatedAt         field.Time
	UpdatedAt         field.Time
	DeletedAt         field.Field
	ChargingStationID field.Uint
	ChargingStation   chargePointBelongsToChargingStation

	fieldMap map[string]field.Expr
}

func (c chargePoint) Table(newTableName string) *chargePoint {
	c.chargePointDo.UseTable(newTableName)
	return c.updateTableName(newTableName)
}

func (c chargePoint) As(alias string) *chargePoint {
	c.chargePointDo.DO = *(c.chargePointDo.As(alias).(*gen.DO))
	return c.updateTableName(alias)
}

func (c *chargePoint) updateTableName(table string) *chargePoint {
	c.ALL = field.NewAsterisk(table)
	c.ID = field.NewUint(table, "id")
	c.CreatedAt = field.NewTime(table, "created_at")
	c.UpdatedAt = field.NewTime(table, "updated_at")
	c.DeletedAt = field.NewField(table, "deleted_at")
	c.ChargingStationID = field.NewUint(table, "charging_station_id")

	c.fillFieldMap()

	return c
}

func (c *chargePoint) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := c.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (c *chargePoint) fillFieldMap() {
	c.fieldMap = make(map[string]field.Expr, 6)
	c.fieldMap["id"] = c.ID
	c.fieldMap["created_at"] = c.CreatedAt
	c.fieldMap["updated_at"] = c.UpdatedAt
	c.fieldMap["deleted_at"] = c.DeletedAt
	c.fieldMap["charging_station_id"] = c.ChargingStationID

}

func (c chargePoint) clone(db *gorm.DB) chargePoint {
	c.chargePointDo.ReplaceConnPool(db.Statement.ConnPool)
	c.ChargingStation.db = db.Session(&gorm.Session{Initialized: true})
	c.ChargingStation.db.Statement.ConnPool = db.Statement.ConnPool
	return c
}

func (c chargePoint) replaceDB(db *gorm.DB) chargePoint {
	c.chargePointDo.ReplaceDB(db)
	c.ChargingStation.db = db.Session(&gorm.Session{})
	return c
}

type chargePointBelongsToChargingStation struct {
	db *gorm.DB

	field.RelationField

	City struct {
		field.RelationField
		Province struct {
			field.RelationField
		}
	}
	ChargePoints struct {
		field.RelationField
		ChargingStation struct {
			field.RelationField
		}
	}
}

func (a chargePointBelongsToChargingStation) Where(conds ...field.Expr) *chargePointBelongsToChargingStation {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a chargePointBelongsToChargingStation) WithContext(ctx context.Context) *chargePointBelongsToChargingStation {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a chargePointBelongsToChargingStation) Session(session *gorm.Session) *chargePointBelongsToChargingStation {
	a.db = a.db.Session(session)
	return &a
}

func (a chargePointBelongsToChargingStation) Model(m *mymodel.ChargePoint) *chargePointBelongsToChargingStationTx {
	return &chargePointBelongsToChargingStationTx{a.db.Model(m).Association(a.Name())}
}

func (a chargePointBelongsToChargingStation) Unscoped() *chargePointBelongsToChargingStation {
	a.db = a.db.Unscoped()
	return &a
}

type chargePointBelongsToChargingStationTx struct{ tx *gorm.Association }

func (a chargePointBelongsToChargingStationTx) Find() (result *mymodel.ChargingStation, err error) {
	return result, a.tx.Find(&result)
}

func (a chargePointBelongsToChargingStationTx) Append(values ...*mymodel.ChargingStation) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a chargePointBelongsToChargingStationTx) Replace(values ...*mymodel.ChargingStation) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a chargePointBelongsToChargingStationTx) Delete(values ...*mymodel.ChargingStation) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a chargePointBelongsToChargingStationTx) Clear() error {
	return a.tx.Clear()
}

func (a chargePointBelongsToChargingStationTx) Count() int64 {
	return a.tx.Count()
}

func (a chargePointBelongsToChargingStationTx) Unscoped() *chargePointBelongsToChargingStationTx {
	a.tx = a.tx.Unscoped()
	return &a
}

type chargePointDo struct{ gen.DO }

type IChargePointDo interface {
	gen.SubQuery
	Debug() IChargePointDo
	WithContext(ctx context.Context) IChargePointDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IChargePointDo
	WriteDB() IChargePointDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IChargePointDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IChargePointDo
	Not(conds ...gen.Condition) IChargePointDo
	Or(conds ...gen.Condition) IChargePointDo
	Select(conds ...field.Expr) IChargePointDo
	Where(conds ...gen.Condition) IChargePointDo
	Order(conds ...field.Expr) IChargePointDo
	Distinct(cols ...field.Expr) IChargePointDo
	Omit(cols ...field.Expr) IChargePointDo
	Join(table schema.Tabler, on ...field.Expr) IChargePointDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IChargePointDo
	RightJoin(table schema.Tabler, on ...field.Expr) IChargePointDo
	Group(cols ...field.Expr) IChargePointDo
	Having(conds ...gen.Condition) IChargePointDo
	Limit(limit int) IChargePointDo
	Offset(offset int) IChargePointDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IChargePointDo
	Unscoped() IChargePointDo
	Create(values ...*mymodel.ChargePoint) error
	CreateInBatches(values []*mymodel.ChargePoint, batchSize int) error
	Save(values ...*mymodel.ChargePoint) error
	First() (*mymodel.ChargePoint, error)
	Take() (*mymodel.ChargePoint, error)
	Last() (*mymodel.ChargePoint, error)
	Find() ([]*mymodel.ChargePoint, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*mymodel.ChargePoint, err error)
	FindInBatches(result *[]*mymodel.ChargePoint, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*mymodel.ChargePoint) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IChargePointDo
	Assign(attrs ...field.AssignExpr) IChargePointDo
	Joins(fields ...field.RelationField) IChargePointDo
	Preload(fields ...field.RelationField) IChargePointDo
	FirstOrInit() (*mymodel.ChargePoint, error)
	FirstOrCreate() (*mymodel.ChargePoint, error)
	FindByPage(offset int, limit int) (result []*mymodel.ChargePoint, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IChargePointDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (c chargePointDo) Debug() IChargePointDo {
	return c.withDO(c.DO.Debug())
}

func (c chargePointDo) WithContext(ctx context.Context) IChargePointDo {
	return c.withDO(c.DO.WithContext(ctx))
}

func (c chargePointDo) ReadDB() IChargePointDo {
	return c.Clauses(dbresolver.Read)
}

func (c chargePointDo) WriteDB() IChargePointDo {
	return c.Clauses(dbresolver.Write)
}

func (c chargePointDo) Session(config *gorm.Session) IChargePointDo {
	return c.withDO(c.DO.Session(config))
}

func (c chargePointDo) Clauses(conds ...clause.Expression) IChargePointDo {
	return c.withDO(c.DO.Clauses(conds...))
}

func (c chargePointDo) Returning(value interface{}, columns ...string) IChargePointDo {
	return c.withDO(c.DO.Returning(value, columns...))
}

func (c chargePointDo) Not(conds ...gen.Condition) IChargePointDo {
	return c.withDO(c.DO.Not(conds...))
}

func (c chargePointDo) Or(conds ...gen.Condition) IChargePointDo {
	return c.withDO(c.DO.Or(conds...))
}

func (c chargePointDo) Select(conds ...field.Expr) IChargePointDo {
	return c.withDO(c.DO.Select(conds...))
}

func (c chargePointDo) Where(conds ...gen.Condition) IChargePointDo {
	return c.withDO(c.DO.Where(conds...))
}

func (c chargePointDo) Order(conds ...field.Expr) IChargePointDo {
	return c.withDO(c.DO.Order(conds...))
}

func (c chargePointDo) Distinct(cols ...field.Expr) IChargePointDo {
	return c.withDO(c.DO.Distinct(cols...))
}

func (c chargePointDo) Omit(cols ...field.Expr) IChargePointDo {
	return c.withDO(c.DO.Omit(cols...))
}

func (c chargePointDo) Join(table schema.Tabler, on ...field.Expr) IChargePointDo {
	return c.withDO(c.DO.Join(table, on...))
}

func (c chargePointDo) LeftJoin(table schema.Tabler, on ...field.Expr) IChargePointDo {
	return c.withDO(c.DO.LeftJoin(table, on...))
}

func (c chargePointDo) RightJoin(table schema.Tabler, on ...field.Expr) IChargePointDo {
	return c.withDO(c.DO.RightJoin(table, on...))
}

func (c chargePointDo) Group(cols ...field.Expr) IChargePointDo {
	return c.withDO(c.DO.Group(cols...))
}

func (c chargePointDo) Having(conds ...gen.Condition) IChargePointDo {
	return c.withDO(c.DO.Having(conds...))
}

func (c chargePointDo) Limit(limit int) IChargePointDo {
	return c.withDO(c.DO.Limit(limit))
}

func (c chargePointDo) Offset(offset int) IChargePointDo {
	return c.withDO(c.DO.Offset(offset))
}

func (c chargePointDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IChargePointDo {
	return c.withDO(c.DO.Scopes(funcs...))
}

func (c chargePointDo) Unscoped() IChargePointDo {
	return c.withDO(c.DO.Unscoped())
}

func (c chargePointDo) Create(values ...*mymodel.ChargePoint) error {
	if len(values) == 0 {
		return nil
	}
	return c.DO.Create(values)
}

func (c chargePointDo) CreateInBatches(values []*mymodel.ChargePoint, batchSize int) error {
	return c.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (c chargePointDo) Save(values ...*mymodel.ChargePoint) error {
	if len(values) == 0 {
		return nil
	}
	return c.DO.Save(values)
}

func (c chargePointDo) First() (*mymodel.ChargePoint, error) {
	if result, err := c.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*mymodel.ChargePoint), nil
	}
}

func (c chargePointDo) Take() (*mymodel.ChargePoint, error) {
	if result, err := c.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*mymodel.ChargePoint), nil
	}
}

func (c chargePointDo) Last() (*mymodel.ChargePoint, error) {
	if result, err := c.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*mymodel.ChargePoint), nil
	}
}

func (c chargePointDo) Find() ([]*mymodel.ChargePoint, error) {
	result, err := c.DO.Find()
	return result.([]*mymodel.ChargePoint), err
}

func (c chargePointDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*mymodel.ChargePoint, err error) {
	buf := make([]*mymodel.ChargePoint, 0, batchSize)
	err = c.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (c chargePointDo) FindInBatches(result *[]*mymodel.ChargePoint, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return c.DO.FindInBatches(result, batchSize, fc)
}

func (c chargePointDo) Attrs(attrs ...field.AssignExpr) IChargePointDo {
	return c.withDO(c.DO.Attrs(attrs...))
}

func (c chargePointDo) Assign(attrs ...field.AssignExpr) IChargePointDo {
	return c.withDO(c.DO.Assign(attrs...))
}

func (c chargePointDo) Joins(fields ...field.RelationField) IChargePointDo {
	for _, _f := range fields {
		c = *c.withDO(c.DO.Joins(_f))
	}
	return &c
}

func (c chargePointDo) Preload(fields ...field.RelationField) IChargePointDo {
	for _, _f := range fields {
		c = *c.withDO(c.DO.Preload(_f))
	}
	return &c
}

func (c chargePointDo) FirstOrInit() (*mymodel.ChargePoint, error) {
	if result, err := c.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*mymodel.ChargePoint), nil
	}
}

func (c chargePointDo) FirstOrCreate() (*mymodel.ChargePoint, error) {
	if result, err := c.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*mymodel.ChargePoint), nil
	}
}

func (c chargePointDo) FindByPage(offset int, limit int) (result []*mymodel.ChargePoint, count int64, err error) {
	result, err = c.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = c.Offset(-1).Limit(-1).Count()
	return
}

func (c chargePointDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = c.Count()
	if err != nil {
		return
	}

	err = c.Offset(offset).Limit(limit).Scan(result)
	return
}

func (c chargePointDo) Scan(result interface{}) (err error) {
	return c.DO.Scan(result)
}

func (c chargePointDo) Delete(models ...*mymodel.ChargePoint) (result gen.ResultInfo, err error) {
	return c.DO.Delete(models)
}

func (c *chargePointDo) withDO(do gen.Dao) *chargePointDo {
	c.DO = *do.(*gen.DO)
	return c
}
