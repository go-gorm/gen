// Code generated by Trae AI. DO NOT EDIT.

package gen

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen/field"
	"gorm.io/plugin/dbresolver"
)

// GenericDo provides a generic base for GORM DAO operations.
// T represents the model type.
// Self represents the concrete DAO type that embeds GenericDo (e.g., *UserDo).
type GenericDo[T any, Self Dao] struct {
	DO // Embed the base DO struct
	modelType reflect.Type
	cloneFunc func(*gorm.DB) Self // Function to clone the embedding DAO
}

// NewGenericDo creates a new GenericDo instance.
// It initializes the underlying DO with the provided database connection and options,
// sets up the model type T, and stores the clone function.
func NewGenericDo[T any, Self Dao](db *gorm.DB, cloneFunc func(*gorm.DB) Self, opts ...DOOption) GenericDo[T, Self] {
	_do := GenericDo[T, Self]{}

	// Store the clone function
	_do.cloneFunc = cloneFunc

	// Initialize the embedded DO
	_do.DO.UseDB(db, opts...)

	// Determine the model type T
	var model T
	_do.modelType = reflect.TypeOf(model)
	if _do.modelType.Kind() == reflect.Ptr {
		_do.modelType = _do.modelType.Elem()
	}

	// Set the model for the underlying gorm.DB instance
	// Use a pointer to T for model registration
	modelPtr := reflect.New(_do.modelType).Interface()
	_do.DO.UseModel(modelPtr)

	return _do
}

// getInstance creates a new instance of the embedding DAO type (Self)
// with the provided gorm.DB instance.
func (d GenericDo[T, Self]) getInstance(db *gorm.DB) Self {
	if d.cloneFunc == nil {
		// This should ideally not happen if constructed correctly
		panic("cloneFunc is not set in GenericDo")
	}
	return d.cloneFunc(db)
}

// --- Override methods to return Self for chaining --- //

func (d GenericDo[T, Self]) WithContext(ctx context.Context) Self {
	return d.getInstance(d.DO.db.WithContext(ctx))
}

func (d GenericDo[T, Self]) Debug() Self {
	return d.getInstance(d.DO.db.Debug())
}

func (d GenericDo[T, Self]) Session(config *gorm.Session) Self {
	return d.getInstance(d.DO.db.Session(config))
}

func (d GenericDo[T, Self]) Clauses(conds ...clause.Expression) Self {
	if err := checkConds(conds); err != nil {
		newDB := d.db.Session(new(gorm.Session))
		_ = newDB.AddError(err)
		return d.getInstance(newDB)
	}
	return d.getInstance(d.DO.db.Clauses(conds...))
}

func (d GenericDo[T, Self]) As(alias string) Self {
	newDO := d.getInstance(d.DO.db.Table(fmt.Sprintf("%s AS %s", d.Quote(d.TableName()), d.Quote(alias))))
	// Manually set the alias on the new instance's embedded DO
	newDO.underlyingDO().alias = alias
	return newDO
}

func (d GenericDo[T, Self]) Not(conds ...Condition) Self {
	exprs, err := condToExpression(conds)
	if err != nil {
		return d.getInstance(d.DO.db.AddError(err))
	}
	return d.getInstance(d.DO.db.Not(exprs))
}

func (d GenericDo[T, Self]) Or(conds ...Condition) Self {
	exprs, err := condToExpression(conds)
	if err != nil {
		return d.getInstance(d.DO.db.AddError(err))
	}
	return d.getInstance(d.DO.db.Or(exprs))
}

func (d GenericDo[T, Self]) Select(conds ...field.Expr) Self {
	return d.getInstance(d.DO.db.Select(exprToInterface(conds)...))
}

func (d GenericDo[T, Self]) Where(conds ...Condition) Self {
	exprs, err := condToExpression(conds)
	if err != nil {
		return d.getInstance(d.DO.db.AddError(err))
	}
	return d.getInstance(d.DO.db.Where(exprs))
}

func (d GenericDo[T, Self]) Order(conds ...field.Expr) Self {
	return d.getInstance(d.DO.db.Order(exprToInterface(conds)...))
}

func (d GenericDo[T, Self]) Distinct(cols ...field.Expr) Self {
	return d.getInstance(d.DO.db.Distinct(exprToInterface(cols)...))
}

func (d GenericDo[T, Self]) Omit(cols ...field.Expr) Self {
	return d.getInstance(d.DO.db.Omit(exprToInterface(cols)...))
}

func (d GenericDo[T, Self]) Join(table schema.Tabler, on ...field.Expr) Self {
	return d.getInstance(d.DO.db.Joins(table.TableName(), exprToInterface(on)...))
}

func (d GenericDo[T, Self]) LeftJoin(table schema.Tabler, on ...field.Expr) Self {
	return d.getInstance(d.DO.db.Joins(fmt.Sprintf("LEFT JOIN %s ON %s", table.TableName(), buildJoinOn(on...))))
}

func (d GenericDo[T, Self]) RightJoin(table schema.Tabler, on ...field.Expr) Self {
	return d.getInstance(d.DO.db.Joins(fmt.Sprintf("RIGHT JOIN %s ON %s", table.TableName(), buildJoinOn(on...))))
}

func (d GenericDo[T, Self]) Group(cols ...field.Expr) Self {
	return d.getInstance(d.DO.db.Group(colsToString(cols)))
}

func (d GenericDo[T, Self]) Having(conds ...Condition) Self {
	exprs, err := condToExpression(conds)
	if err != nil {
		return d.getInstance(d.DO.db.AddError(err))
	}
	return d.getInstance(d.DO.db.Having(exprs))
}

func (d GenericDo[T, Self]) Limit(limit int) Self {
	return d.getInstance(d.DO.db.Limit(limit))
}

func (d GenericDo[T, Self]) Offset(offset int) Self {
	return d.getInstance(d.DO.db.Offset(offset))
}

func (d GenericDo[T, Self]) Scopes(funcs ...func(Dao) Dao) Self {
	gormFuncs := make([]func(*gorm.DB) *gorm.DB, len(funcs))
	for i, f := range funcs {
		// Capture the loop variable
		currentFunc := f
		gormFuncs[i] = func(db *gorm.DB) *gorm.DB {
			// Create a temporary DO wrapper for the scope function
			tempDO := &DO{}
			tempDO.db = db
			tempDO.DOConfig = d.DOConfig // Inherit config
			// Apply the scope function
			resultDO := currentFunc(tempDO)
			// Return the underlying gorm.DB from the result
			return resultDO.underlyingDB()
		}
	}
	return d.getInstance(d.DO.db.Scopes(gormFuncs...))
}

func (d GenericDo[T, Self]) Unscoped() Self {
	return d.getInstance(d.DO.db.Unscoped())
}

func (d GenericDo[T, Self]) Attrs(attrs ...field.AssignExpr) Self {
	return d.getInstance(d.DO.db.Attrs(assignExprToInterface(attrs)...))
}

func (d GenericDo[T, Self]) Assign(attrs ...field.AssignExpr) Self {
	return d.getInstance(d.DO.db.Assign(assignExprToInterface(attrs)...))
}

func (d GenericDo[T, Self]) Joins(fields ...field.RelationField) Self {
	newDB := d.DO.db
	for _, f := range fields {
		newDB = newDB.Joins(f.Name())
	}
	return d.getInstance(newDB)
}

func (d GenericDo[T, Self]) Preload(fields ...field.RelationField) Self {
	newDB := d.DO.db
	for _, f := range fields {
		newDB = newDB.Preload(f.Name())
	}
	return d.getInstance(newDB)
}

func (d GenericDo[T, Self]) ReadDB() Self {
	return d.Clauses(dbresolver.Read)
}

func (d GenericDo[T, Self]) WriteDB() Self {
	return d.Clauses(dbresolver.Write)
}

// --- Result methods adapted for GenericDo[T, Self] --- //

func (d GenericDo[T, Self]) Create(values ...*T) error {
	if len(values) == 0 {
		return nil
	}
	// Convert []*T to []interface{}
	interfaces := make([]interface{}, len(values))
	for i, v := range values {
		interfaces[i] = v
	}
	return d.DO.db.Create(interfaces).Error
}

func (d GenericDo[T, Self]) CreateInBatches(values []*T, batchSize int) error {
	// Convert []*T to []interface{}
	interfaces := make([]interface{}, len(values))
	for i, v := range values {
		interfaces[i] = v
	}
	return d.DO.db.CreateInBatches(interfaces, batchSize).Error
}

func (d GenericDo[T, Self]) Save(values ...*T) error {
	if len(values) == 0 {
		return nil
	}
	// Convert []*T to []interface{}
	interfaces := make([]interface{}, len(values))
	for i, v := range values {
		interfaces[i] = v
	}
	return d.DO.db.Save(interfaces).Error
}

func (d GenericDo[T, Self]) First() (*T, error) {
	result := new(T)
	err := d.DO.db.First(result).Error
	return result, err
}

func (d GenericDo[T, Self]) Take() (*T, error) {
	result := new(T)
	err := d.DO.db.Take(result).Error
	return result, err
}

func (d GenericDo[T, Self]) Last() (*T, error) {
	result := new(T)
	err := d.DO.db.Last(result).Error
	return result, err
}

func (d GenericDo[T, Self]) Find() ([]*T, error) {
	results := make([]*T, 0)
	err := d.DO.db.Find(&results).Error
	return results, err
}

func (d GenericDo[T, Self]) FindInBatch(batchSize int, fc func(tx Dao, batch int) error) (results []*T, err error) {
	buf := make([]*T, 0, batchSize)
	err = d.DO.FindInBatches(&buf, batchSize, func(tx *gorm.DB, batch int) error {
		// Wrap the gorm.DB with a temporary DO for the callback
        tempDO := &DO{}
        tempDO.db = tx
        tempDO.DOConfig = d.DOConfig // Inherit config
		defer func() { results = append(results, buf...) }()
		return fc(tempDO, batch)
	})
	return results, err
}

func (d GenericDo[T, Self]) FindInBatches(result *[]*T, batchSize int, fc func(tx Dao, batch int) error) error {
	return d.DO.FindInBatches(result, batchSize, func(tx *gorm.DB, batch int) error {
        // Wrap the gorm.DB with a temporary DO for the callback
        tempDO := &DO{}
        tempDO.db = tx
        tempDO.DOConfig = d.DOConfig // Inherit config
        return fc(tempDO, batch)
    })
}

func (d GenericDo[T, Self]) FirstOrInit() (*T, error) {
	result := new(T)
	err := d.DO.db.FirstOrInit(result).Error
	return result, err
}

func (d GenericDo[T, Self]) FirstOrCreate() (*T, error) {
	result := new(T)
	err := d.DO.db.FirstOrCreate(result).Error
	return result, err
}

func (d GenericDo[T, Self]) Update(column field.Expr, value interface{}) (info ResultInfo, err error) {
	result := d.DO.db.Model(new(T)).Update(column.String(), value)
	return ResultInfo{RowsAffected: result.RowsAffected, Error: result.Error}, result.Error
}

func (d GenericDo[T, Self]) UpdateSimple(columns ...field.AssignExpr) (info ResultInfo, err error) {
	result := d.DO.db.Model(new(T)).Updates(d.DO.db.Statement.Context, assignExprToMap(d.DO.db, columns...))
	return ResultInfo{RowsAffected: result.RowsAffected, Error: result.Error}, result.Error
}

func (d GenericDo[T, Self]) Updates(value interface{}) (info ResultInfo, err error) {
	result := d.DO.db.Model(new(T)).Updates(value)
	return ResultInfo{RowsAffected: result.RowsAffected, Error: result.Error}, result.Error
}

func (d GenericDo[T, Self]) UpdateColumn(column field.Expr, value interface{}) (info ResultInfo, err error) {
	result := d.DO.db.Model(new(T)).UpdateColumn(column.String(), value)
	return ResultInfo{RowsAffected: result.RowsAffected, Error: result.Error}, result.Error
}

func (d GenericDo[T, Self]) UpdateColumnSimple(columns ...field.AssignExpr) (info ResultInfo, err error) {
	result := d.DO.db.Model(new(T)).UpdateColumns(assignExprToMap(d.DO.db, columns...))
	return ResultInfo{RowsAffected: result.RowsAffected, Error: result.Error}, result.Error
}

func (d GenericDo[T, Self]) UpdateColumns(value interface{}) (info ResultInfo, err error) {
	result := d.DO.db.Model(new(T)).UpdateColumns(value)
	return ResultInfo{RowsAffected: result.RowsAffected, Error: result.Error}, result.Error
}

func (d GenericDo[T, Self]) Delete(values ...*T) (info ResultInfo, err error) {
    // Convert []*T to []interface{}
    interfaces := make([]interface{}, len(values))
    for i, v := range values {
        interfaces[i] = v
    }
    result := d.DO.db.Delete(interfaces)
    return ResultInfo{RowsAffected: result.RowsAffected, Error: result.Error}, result.Error
}

func (d GenericDo[T, Self]) Count() (count int64, err error) {
	err = d.DO.db.Model(new(T)).Count(&count).Error
	return
}

func (d GenericDo[T, Self]) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	resultType := reflect.TypeOf(result)
	if resultType.Kind() != reflect.Ptr {
		err = fmt.Errorf("ScanByPage: result must be a pointer, got %T", result)
		return
	}

	// Get the total count first
	count, err = d.Count()
	if err != nil {
		return
	}

	// Apply offset and limit for the scan
	err = d.DO.db.Offset(offset).Limit(limit).Scan(result).Error
	return
}

func (d GenericDo[T, Self]) FindByPage(offset int, limit int) (result []*T, count int64, err error) {
	result = make([]*T, 0)
	// Get the total count first
	count, err = d.Count()
	if err != nil {
		return
	}

	// Apply offset and limit for the find
	err = d.DO.db.Offset(offset).Limit(limit).Find(&result).Error
	return
}

// --- Raw SQL methods remain largely the same, inherited from DO --- //
// --- Helper methods (like underlyingDB, etc.) remain the same --- //

// --- Interface compliance --- //

// // SubQuery interface (if needed, adapt from DO)
// func (d GenericDo[T]) SubQuery() SubQueryInfo {
// 	// ... implementation based on DO.SubQuery ...
// }

// schema.Tabler interface
func (d GenericDo[T]) TableName() string {
	return d.DO.TableName()
}

// Add other necessary methods by adapting from gen.DO or specific xxxDo implementations
// Ensure type safety and correct handling of the generic type T.

// Helper function (consider moving to a shared utility if used elsewhere)
func buildJoinOn(on ...field.Expr) string {
	var builder strings.Builder
	for i, expr := range on {
		if i > 0 {
			builder.WriteString(" AND ")
		}
		expr.Build(&builder)
	}
	return builder.String()
}

// IGenericDO defines the interface for GenericDo, allowing for mocking and dependency injection.
// T represents the model type.
// Self represents the concrete DAO type (e.g., *UserDo).
type IGenericDO[T any, Self Dao] interface {
	// Basic operations that return Self
	As(alias string) Self
	Not(conds ...Condition) Self
	Or(conds ...Condition) Self
	Select(conds ...field.Expr) Self
	Where(conds ...Condition) Self
	Order(conds ...field.Expr) Self
	Distinct(cols ...field.Expr) Self
	Omit(cols ...field.Expr) Self
	Join(table schema.Tabler, on ...field.Expr) Self
	LeftJoin(table schema.Tabler, on ...field.Expr) Self
	RightJoin(table schema.Tabler, on ...field.Expr) Self
	Group(cols ...field.Expr) Self
	Having(conds ...Condition) Self
	Limit(limit int) Self
	Offset(offset int) Self
	Scopes(funcs ...func(Dao) Dao) Self
	Unscoped() Self
	Attrs(attrs ...field.AssignExpr) Self
	Assign(attrs ...field.AssignExpr) Self
	Returning(value interface{}, columns ...string) Self // Returning should also return Self
	Preload(query string, args ...interface{}) Self // Preload should also return Self
	ReplaceDB(db *gorm.DB) Self // ReplaceDB should also return Self
	WithContext(ctx context.Context) Self
	Debug() Self
	Session(config *gorm.Session) Self
	Clauses(conds ...clause.Expression) Self
	ReadDB() Self
	WriteDB() Self
	MasterDB() Self // Assuming MasterDB exists and should return Self
	Joins(fields ...field.RelationField) Self
	// Methods inherited from Dao or DO that don't return Self
	UseDB(db *gorm.DB, opts ...DOOption)
	UseModel(model interface{})
	UseTable(tableName string)
	TableName() string
	Pluck(column field.Expr, dest interface{}) error
	Scan(dest interface{}) error
	// Result methods returning specific types or errors
	FirstOrInit() (*T, error)
	FirstOrCreate() (*T, error)
	FindByPage(offset int, limit int) (result []*T, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Create(value *T) error
	CreateInBatches(values []*T, batchSize int) error
	Save(values ...*T) error
	First() (*T, error)
	Take() (*T, error)
	Last() (*T, error)
	Find() ([]*T, error)
	FindInBatch(batchSize int, fc func(tx Dao, batch int) error) error
	Update(column field.Expr, value interface{}) (info ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info ResultInfo, err error)
	Updates(values interface{}) (info ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info ResultInfo, err error)
	UpdateColumns(values interface{}) (info ResultInfo, err error)
	UpdateFrom(q subQuery) Dao // UpdateFrom might need adjustment depending on its usage
	Delete(...*T) (info ResultInfo, err error)
	Count() (int64, error)
	Row() *sql.Row
	Rows() (*sql.Rows, error)
	Sum(expr field.Expr) (sql.NullFloat64, error)
	Avg(expr field.Expr) (sql.NullFloat64, error)
	Min(expr field.Expr) (sql.NullFloat64, error)
	Max(expr field.Expr) (sql.NullFloat64, error)
	GetField(expr field.Expr) (field.Expr, error)
	Begin() *Txx
	Commit() *Txx
	Rollback() *Txx
	SavePoint(name string) *Txx
	RollbackTo(name string) *Txx
}

// GenericDo provides a generic base for GORM DAO operations.
// T represents the model type.
type GenericDo[T any] struct {
	DO // Embed the base DO struct
	modelType reflect.Type
}